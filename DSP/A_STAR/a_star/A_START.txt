mapping.h 头文件

#ifndef MAPPING_H
#define MAPPING_H
#include <string>
#include <opencv2/opencv.hpp>
#include <iostream>
#include<stdio.h>
#include<malloc.h>

using namespace cv;
using namespace std;
/*  一些预定义  */
#define MaxVerNum 729 /*定义最大节点数*/
int flag[729];
Mat img(580, 980, CV_8UC3);//读入图像


/*   建图需要的结构体  */
struct node
{
    int adjvex ;//节点号
    struct node *next ; //指向下一个邻接节点域
};
struct vnode//链表头节点
{
    int vertex; //放flag
    node *firstedge ; //边表头指针
};
struct AGraph
{
    vnode adjList[729] ; //邻接表
    int n; //顶点数
    int e=0; //边数
};

struct a_node1
{
    int num;
    int set;//0 open 1 close 2 unkown
    int g;
    int h;
    int f;
    int parent;
};


/* ．．．．．．．  地图显示   ．．．．．．．．*/
class mapping1
{

private:

    AGraph *GG ;
    a_node1 aa_node1[729];
   //Mat img(580, 580, CV_8UC3);//读入图像
    Point root_points[729][4];
    Point root_point[4];
    vector<int> g_path;
public:
    mapping1()
    {
        start_num=702;
        stop_num=26;
        g_path.clear();
    }
    int start_num,stop_num;
    void mapping1_init();//无参构造函数
    void map_show();
    void CreateALGraph();
    void a_star1();
};
#endif // MAPPING_H


mapping.hpp

#include <string>
#include <opencv2/opencv.hpp>
#include <iostream>
#include<stdio.h>
#include<malloc.h>
#include <mapping.h>
#include <vector>


using namespace cv;
using namespace std;
mapping1 ma;
/* ．．．．．．．  地图显示   ．．．．．．．．*/
void mapping1::mapping1_init()//无参构造函数
{
    //start_num=702;
    //flag[]={0};
    for(int i=0;i<729;i++)
    {
        flag[i]=0;
    }
    for(int i=0;i<10;i++)
    {
        flag[10+i*27]=1;
    }
    for(int i=0;i<3;i++)
    {
        flag[254+i]=1;
    }
    for(int i=0;i<5;i++)
    {
        flag[257+i-54]=1;
        flag[257+i-27]=1;
        flag[257+i]=1;
        flag[257+i+27]=1;
    }
    for(int i=0;i<4;i++)
    {
        flag[73+i]=1;
        flag[73+i+27]=1;
        flag[73+i+54]=1;
    }
    for(int i=0;i<6;i++)
    {
        flag[185+i*27]=1;
    }
    for(int i=0;i<15;i++)
    {
        flag[363+i]=1;
    }
    for(int i=0;i<7;i++)
    {
        flag[328+i]=1;
    }
    for(int i=0;i<5;i++)
    {
        flag[334+(i+1)*27]=1;
    }
    for(int i=0;i<7;i++)
    {
        flag[493+i]=1;
        flag[493+i+27]=1;
        flag[493+i+54]=1;
    }
    for(int i=0;i<8;i++)
    {
        flag[621+i]=1;
    }
    for(int i=0;i<4;i++)
    {
        flag[606+i]=1;
        flag[606+i+27]=1;
        flag[606+i+54]=1;
        flag[606+i+81]=1;
        flag[606+i+108]=1;
    }
    flag[stop_num]=3;//目标点,
    flag[start_num]=4;//起始点
}


void mapping1::map_show()//地图显示
{
    for(int i=0;i<729;i++)
    {
        root_points[i][0] = Point((i%27+1)*20, (i/27+1)*20);
        root_points[i][1] = Point((i%27+1)*20+20, (i/27+1)*20);
        root_points[i][2] = Point((i%27+1)*20+20, (i/27+1)*20+20);
        root_points[i][3] = Point((i%27+1)*20, (i/27+1)*20+20);
        const Point* ppt[1] = { root_points[i] };
        int npt[] = { 4 };
        if(1==flag[i])
        {
            fillPoly(img, ppt, npt, 1, Scalar(0,0,0));
        }
        else if(0==flag[i])
        {
            fillPoly(img, ppt, npt, 1, Scalar(255,255,255));
        }
        else if(3==flag[i])
        {
            fillPoly(img, ppt, npt, 1, Scalar(0,0,255));
        }
        else if(4==flag[i])
        {
            fillPoly(img, ppt, npt, 1, Scalar(255,0,0));
        }
        else if(7==flag[i])
        {
            string tmpstring=to_string(aa_node1[i].g);
            fillPoly(img, ppt, npt, 1, Scalar(100,205,255));
            putText(img,tmpstring,Point((i%27+1)*20+3, (i/27+1)*20+16),FONT_HERSHEY_SIMPLEX,0.4,Scalar(255,23,0),1,8);

        }
        else
        {
            string tmpstring=to_string(aa_node1[i].g);
            fillPoly(img, ppt, npt, 1, Scalar(0,255,255));
            putText(img,tmpstring,Point((i%27+1)*20+3, (i/27+1)*20+16),FONT_HERSHEY_SIMPLEX,0.4,Scalar(255,23,0),1,8);
        }
    }
    for(int i=0;i<28;i++)
    {
        line(img,Point((i+1)*20,20),Point((i+1)*20,560),Scalar(0,0,255),1,CV_AA);
        line(img,Point(20,(i+1)*20),Point(560,(i+1)*20),Scalar(0,0,255),1,CV_AA);
    }

    root_point[0] = Point(600, 20);
    root_point[1] = Point(960,20);
    root_point[2] = Point(960,560);
    root_point[3] = Point(600,560);
    const Point* ppt[1] = { root_point };
    int npt[] = { 4 };
    fillPoly(img, ppt, npt, 1, Scalar(255,255,255));
    string tmpstring="A_Star Algorithm";
    putText(img,tmpstring,Point(620,50),FONT_HERSHEY_SIMPLEX,1,Scalar(0,0,255),2,8);
    if(aa_node1[stop_num].set==1)
    {
        tmpstring="Minimum number of steps:"+to_string(aa_node1[stop_num].g);
        putText(img,tmpstring,Point(620,70),FONT_HERSHEY_SIMPLEX,0.5,Scalar(0,0,255),1,8);
        tmpstring="The shortest path:";
        putText(img,tmpstring,Point(620,100),FONT_HERSHEY_SIMPLEX,0.5,Scalar(0,0,255),1,8);
        int m_size=g_path.size();
        int m_h;
        if(0==m_size%5)
        {
            m_h=m_size/5;
        }
        else
        {
            m_h=m_size/5+1;
        }

        for(int i=0;i<m_h;i++)
        {
            tmpstring.clear();
            for(int j=0;j<5;j++)
            {
                if(g_path.back()>=100)
                    tmpstring=tmpstring+to_string(g_path.back());
                else if(g_path.back()>=10)
                    tmpstring=tmpstring+to_string(0)+to_string(g_path.back());
                else
                    tmpstring=tmpstring+to_string(0)+to_string(0)+to_string(g_path.back());
                g_path.pop_back();
                if(g_path.empty())
                    break;
                else
                    tmpstring=tmpstring+"->";
            }
            putText(img,tmpstring,Point(620,120+20*i),FONT_HERSHEY_SIMPLEX,0.5,Scalar(0,0,255),1,8);
        }

    }

}

void mapping1::CreateALGraph()//建图
{
    this->GG = (AGraph*)malloc(sizeof(AGraph)) ;
    int i ;
    node *s ;
    this->GG->n=729;
    for( i = 0 ; i <this->GG->n ; i++)
    {
        this->GG->adjList[i].vertex=flag[i];//flag
        this->GG->adjList[i].firstedge = NULL ; //将顶点的边表头指针设置为空
        /*   判断边的信息  */
        if((flag[i]!=1)&&(i%27!=0)&&(flag[i-1]!=1))//右边的边
        {
            this->GG->e++;
            s = (node*)malloc(sizeof(node)) ;
            s->adjvex = i-1 ;
            s->next = this->GG->adjList[i].firstedge ;
            this->GG->adjList[i].firstedge = s ;
        }

        if((flag[i]!=1)&&((i+1)%27!=0)&&(flag[i+1]!=1))//右边的边
        {
            this->GG->e++;
            s = (node*)malloc(sizeof(node)) ;
            //边上的第一个节点
            s->adjvex = i+1 ;
            s->next = this->GG->adjList[i].firstedge ;
            this->GG->adjList[i].firstedge = s ;
        }

        if((flag[i]!=1)&&(i-27>0)&&(flag[i-27]!=1))//下面的边
        {
            this->GG->e++;
            s = (node*)malloc(sizeof(node)) ;
            //边上的第一个节点
            s->adjvex = i;
            s->next = this->GG->adjList[i-27].firstedge ;
            this->GG->adjList[i-27].firstedge = s ;
            //边上的第二个节点
            s = (node*)malloc(sizeof(node)) ;
            s->adjvex = i-27;
            s->next = this->GG->adjList[i].firstedge ;
            this->GG->adjList[i].firstedge = s ;
        }

        if((flag[i]!=1)&&(i+27<729)&&(flag[i+27]!=1))//下面的边
        {
            this->GG->e++;
            s = (node*)malloc(sizeof(node)) ;
            s->adjvex = i;
            s->next = this->GG->adjList[i+27].firstedge ;
            this->GG->adjList[i+27].firstedge = s ;
        }
    }
}


void mapping1::a_star1()//A*算法
{
    int tmp_num,tmp_f;
    for(int i=0;i<729;i++)
    {
        aa_node1[i].num=i;
        aa_node1[i].set=2;
        aa_node1[i].g=999;
        if(i==start_num)
        {
            aa_node1[i].set=0;//把起始点放在开集里
            aa_node1[i].g=0;
        }
        aa_node1[i].h=abs(i/27-stop_num/27)+abs(i%27-stop_num%27);
        aa_node1[i].f=aa_node1[i].g+aa_node1[i].h;
        aa_node1[i].parent=-1;
    }
    while(aa_node1[stop_num].set!=1)
    {
        /* 2.1-----3  */
        tmp_num=-1;
        tmp_f=1599;
        for(int i=0;i<729;i++)//在开集中找最小的ｆ
        {
            if(0==aa_node1[i].set)
            {
                if(tmp_f>=aa_node1[i].f)
                {
                    if(tmp_f==aa_node1[i].f)
                    {
                        if(aa_node1[i].h<aa_node1[tmp_num].h)
                        {
                            tmp_num=i;
                            tmp_f=aa_node1[i].f;
                            continue;
                        }
                        else
                        {
                            continue;
                        }
                    }
                    tmp_num=i;
                    tmp_f=aa_node1[i].f;
                }
            }
        }
        aa_node1[tmp_num].set=1;//把最小的ｆ的点放在闭集里面
        if((tmp_num!=start_num)&&tmp_num!=stop_num)
            flag[tmp_num]=7;
        this->map_show();
        imshow("image", img);
        waitKey(3);
        node *stmp;
        stmp = (node*)malloc(sizeof(node)) ;
        stmp= GG->adjList[aa_node1[tmp_num].num].firstedge ;
        int tmp;
        while(stmp!=NULL)
        {
            tmp=stmp->adjvex;

            if((aa_node1[tmp_num].g+1)<aa_node1[tmp].g)
            {
                aa_node1[tmp].g=aa_node1[tmp_num].g+1;
                aa_node1[tmp].parent=tmp_num;
            }
            aa_node1[tmp].f=aa_node1[tmp].g+aa_node1[tmp].h;//更新ｆ
            if(2==aa_node1[tmp].set)
                aa_node1[tmp].set=0;
            stmp=stmp->next;
        }
        //cout<<tmp_num<<" ";
    }

    int tmp_n=aa_node1[stop_num].parent;
    g_path.push_back(stop_num);
    //path
    while(tmp_n!=start_num)
    {
        g_path.push_back(tmp_n);
        flag[tmp_n]=2;
        tmp_n=aa_node1[tmp_n].parent;
    }
    g_path.push_back(start_num);

}

main.cpp

#include <string>
#include <opencv2/opencv.hpp>
#include <iostream>
#include<stdio.h>
#include<malloc.h>
#include <mapping.hpp>

using namespace cv;
using namespace std;
extern mapping1 ma;
void on_mouse(int event,int x,int y,int flags,void *ustc)//event鼠标事件代号，x,y鼠标坐标，flags拖拽和键盘操作的代号
{
   if (event == CV_EVENT_LBUTTONDOWN)//左键按下，读取初始坐标，并在图像上该点处划圆
   {
       if(x>20&&x<560&&y>20&&y<560)
       {
           int tmp=(y/20-1)*27+x/20-1;
           if(flag[tmp]!=1)
           {
               ma.stop_num=tmp;
               ma.mapping1_init();
               ma.a_star1();
               ma.map_show();
            }
       }
   }
   if (event == CV_EVENT_RBUTTONDOWN)//左键按下，读取初始坐标，并在图像上该点处划圆
   {
       if(x>20&&x<560&&y>20&&y<560)
       {
           int tmp=(y/20-1)*27+x/20-1;
           if(flag[tmp]!=1)
           {
               ma.start_num=tmp;
               ma.mapping1_init();
               ma.a_star1();
               ma.map_show();
            }
       }
   }
   if (event == CV_EVENT_MBUTTONDOWN)//左键按下，读取初始坐标，并在图像上该点处划圆
   {
       if(x>20&&x<560&&y>20&&y<560)
       {
               ma.start_num=702;
               ma.stop_num=26;
               ma.mapping1_init();
               ma.a_star1();
               ma.map_show();
       }
   }
   imshow("image", img);
}


int main()
{
    ma.mapping1_init();
    ma.CreateALGraph() ;
    namedWindow("image",1);
    ma.a_star1();
    ma.map_show();
    setMouseCallback("image",on_mouse,0);//调用回调函数
    imshow("image", img);

    waitKey(0);

    return 0;
}


